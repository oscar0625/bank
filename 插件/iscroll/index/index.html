<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" href="reset.css">
    <style>
        #wrapper{
            width: 200px;
            height: 200px;
            overflow: hidden;
            position: relative;
        }
    </style>
</head>
<body>
<div id="wrapper">
    <!--只有wrapper里的第一个子元素（ul）才可以被实例化滚动，并且要结合外层的DOM（wrapper）才能实现滚动。-->
    <ul>
        <li>1</li>
        <li>2</li>
        <li class="target">3</li>
        <li>4</li>
        <li>5</li>
        <li>6</li>
        <li>7</li>
        <li>8</li>
        <li>9</li>
        <li>10</li>
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
        <li>6</li>
        <li>7</li>
        <li>8</li>
        <li>9</li>
        <li>10</li>
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
        <li>6</li>
        <li>7</li>
        <li>8</li>
        <li>9</li>
        <li>10</li>
    </ul>
</div>
<button class="add">add</button>
<button class="backTop">回到顶部</button>
<button class="tiao">跳</button>
<script src="iscroll.min.js"></script>
<script>
    /*
     * http://wiki.jikexueyuan.com/project/iscroll-5/customevents.html  iscroll 5.1.2
     * http://www.360doc.com/content/14/0724/11/16276861_396699901.shtml  iscroll 4.2.5
     *
     * 注意当DOM准备完成后iScroll需要被初始化。最保险的方式是在window的onload事件中启动它。因为脚本需要知道滚动区域的高度和宽度。如果你有一些图片在滚动区域导致不能立马获取区域的高度和宽度，iScroll的滚动尺寸有可能会错误。
     * */
    /*实际问题：
    * 要想实例化  必须保证 #wrapper 这个元素是存在的 display：none 不可以
    * 若指定 snap: 'li' 则里面必须有li 元素
    *
    * */
    var myScroll;
    window.onload=function () {
        myScroll=new IScroll("#wrapper",{
            bounce:true, //当滚动器到达容器边界时他将执行一个小反弹动画(true) 默认true
            mouseWheel: true, //开启滚轮 默认false 不开启
            snap: true, //对齐（精确捕捉元素） 默认情况下，iScroll将wrapper分成四分体，snap: true,snap属性的值是滚动条将要对齐到的元素的选择器。
            momentum:false//在用户快速触摸屏幕时，你可以开/关势能动画。关闭此功能将大幅度提升性能 默认true。
//          scrollX: false,//是否允许水平滚动 默认false 不允许
//          scrollY: true, //是否允许垂直滚动 默认true 允许

            //手机端事件
//          tap:true  //设置此属性为true，当滚动区域被点击或者触摸但并没有滚动时，可以让iScroll抛出一个自定义的tap事件。
//          element.addEventListener('tap', doSomething, false);
//          tap: 'myCustomTapEvent'  也可以通过传递一个字符串来自定义事件名称
        });

        /*事件*/
        myScroll.on('类型',function () {});
        // 1.beforeScrollStart 在用户触摸屏幕但还没有开始滚动时触发。
        // 2.scrollStart 在用户开始滚动时触发。
        // 3.scrollEnd 在用户结束滚动时触发。
        // 4.refresh  refresh方法的回调
        // 5.destroy  destroy方法的回调
        // 6.zoomStart  开始缩放
        // 7.zoomEnd  缩放结束
        // 8.scroll  滚动条滚动的时候触发  /***iscroll-probe.js 才可以 只限于拖动滚动条 滚动滚轮不好使 还需在属性里设置 probeType: 1(不影响性能)/2(等同于原生的scoll事件)/3(精密像素级别触发)*****/
        /*滚动条信息*/
        //myScroll.x 滚动到的当前位置
        //myScroll.y 滚动到的当前位置

    };


    /*其他一些方法*/
    // 1. refresh 往wrapper ul 里添加心元素 需要重新刷新 myscroll
    document.querySelector('.add').onclick=function () {
        var li=document.createElement('li');
        li.innerHTML='11';
        document.querySelector('#wrapper ul').appendChild(li);
        myScroll.refresh(); //当DOM结构发生变化的时候，需要刷新iScroll
    };

    // 2. 移动到固定位置 scrollTo(x, y, time, easing)方法：传入4个参数：X轴位置，Y轴位置（初始0，0）效果时间，滚动轨迹(quadratic, circular, back, bounce elastic)
    document.querySelector('.backTop').onclick=function () {
        myScroll.scrollTo(0, 0, 1000, IScroll.utils.ease.elastic)
    };

    // 3.scrollToElement(el, time, offsetX, offsetY, easing)在这个方法中只有一个强制的参数就是el。传递一个元素或者一个选择器，iScroll将尝试滚动到这个元素的左上角位置。time是可选项，用于设置动画周期。offsetX 和 offsetY定义像素级的偏移量，所以你可以滚动到元素并且加上特别的偏移量。但并不仅限于此。如果把这两个参数设置为true，元素将会位于屏幕的中间。
    document.querySelector('.tiao').onclick=function () {
        myScroll.scrollToElement('.target')
    };

    // 4.销毁Destroy  在不需要使用iScoll的时候调用iScroll实例的公共方法destroy()可以释放一些内存。
    //    myScroll.destroy();
    //    myScroll = null;


</script>
</body>
</html>