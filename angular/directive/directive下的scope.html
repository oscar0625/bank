<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="js/angular-1.3.9.js"></script>
</head>
<!--
    配置对象:
        scope:
            false   指令中的$scope下的一切变量归为全局，和指令的父级控制器互相影响，父作用于子，子干扰父，发生冲突测覆盖；
            true    指令中的$scope下的一切变量仅仅作用于自身,会从父级继承变量（父作用于子）,但不会影响其父级，冲突时会以自身为主；（符合正常情况）
            {}      完全独立，不受外界影响，也不会干扰外界；
              开一个口
              1. 如果指令中的controller/link/compile中定义了这个变量(有这个变量)
                    讲指令中的这个变量传送给父级(子传父)
              2. 如果指令中的controller/link/compile中没有定义变量(没有这个变量)
                    那么在指令中会先定义这个变量，然后将父级中的变量值给子（父传子）
                js:
                    scope:{
                        指令中的变量: '=属性名'
                    }
                html:
                    <div 指令名   属性名="父级作用域中的变量">
               如果 在{}的情况下要讲父级的一个变量传进来，可以再调用指令的时候用 属性=变量 的形式传进来 在控制器中用attrs接收
-->
<body ng-app="app" ng-controller="ctrl">
<fieldset>
    <legend>父</legend>
    <input type="text" ng-model="name">
    <p>{{name}}</p>
</fieldset>
<div my-dir my-value="name" qwe="{{mvc}}"></div>
</body>
<script>
    angular.module('app',[])
        .controller('ctrl',['$scope',function ($scope) {
            $scope.name=null;
            $scope.mvc='哈哈'
        }])
        .controller('asd',['$scope','$attrs',function ($scope,$attrs) {
            $scope.name='caroline';
            console.log($attrs);
        }])
        .directive('myDir',function () {
            return{
                templateUrl:'01.html',
                controller:'asd',
                replace:true,
                restrict:'AE',
                scope:{
                    name:'=myValue'
                }
            }
        }
        )



</script>
</html>